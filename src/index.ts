import { app, BrowserWindow, screen } from "electron";
import express, { Express } from "express";
import fs from "fs";
import path from "path";
import { Image } from "image-js";
import bodyParser from "body-parser";

enum ColorModel {
  GREY = 'GREY',
  RGB = 'RGB',
  HSL = 'HSL',
  HSV = 'HSV',
  CMYK = 'CMYK',
}

const portFilePath = path.join(process.cwd(), ".liv-port");

let globalMainWindow: BrowserWindow | null = null;
let globalReportInterval: NodeJS.Timeout | null = null;
let reportPort = false;

const scaleModes = ["fit-preserve-aspect", "unchanged"] as const;

type ScaleMode = (typeof scaleModes)[number];

// This allows TypeScript to pick up the magic constants that's auto-generated by Forge's Webpack
// plugin that tells the Electron app where to look for the Webpack-bundled app code (depending on
// whether you're running in development or production).
declare const MAIN_WINDOW_WEBPACK_ENTRY: string;
declare const MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY: string;

// Handle creating/removing shortcuts on Windows when installing/uninstalling.
if (require("electron-squirrel-startup")) {
  app.quit();
}

// Variable to hold the Express server reference
let expressServer: ReturnType<Express["listen"]> | null = null;

type ImageData = {
  name: string;
  width: number;
  height: number;
  channels: number;
  data: Uint8ClampedArray;
  scaleMode: ScaleMode;
};

const activeImageData: ImageData = {
  name: "",
  width: 0,
  height: 0,
  channels: 0,
  data: new Uint8ClampedArray(0).fill(0),
  scaleMode: "fit-preserve-aspect",
};

// Create the Express server
const createExpressServer = async (): Promise<void> => {
  const expressApp = express();

  expressApp.use(bodyParser.json());

  // A route meant for clients to upload images as pixel data
  // It is called /pixels instead of /upload since it
  // is not uploading a file, just uploading pixel data
  // This is why a name is needed as it cannot be derived from
  // a file path
  expressApp.post("/pixels/begin", (req, res) => {
    if (typeof req.body !== "object" || req.body === null) {
      return res.status(400).json({
        message: "Request body must be an object",
      });
    }
    if (
      typeof req.body.name !== "string" ||
      typeof req.body.width !== "number" ||
      typeof req.body.height !== "number" ||
      typeof req.body.channels !== "number" ||
      typeof req.body.scaleMode !== "string"
    ) {
      return res.status(400).json({
        message:
          "Request body must contain 'name', 'width', 'height', and 'channels' properties",
      });
    }
    if (!scaleModes.includes(req.body.scaleMode as ScaleMode)) {
      return res.status(400).json({
        message: `Invalid scale mode. Must be one of: ${scaleModes.join(", ")}`,
      });
    }
    const reqObject = req.body as {
      name: string;
      width: number;
      height: number;
      channels: number;
      scaleMode: ScaleMode;
    };
    const dataLength = reqObject.width * reqObject.height * reqObject.channels;
    activeImageData.name = reqObject.name;
    activeImageData.width = reqObject.width;
    activeImageData.height = reqObject.height;
    activeImageData.channels = reqObject.channels;
    activeImageData.data = new Uint8ClampedArray(dataLength).fill(0);
    activeImageData.scaleMode = reqObject.scaleMode;
    return res.status(204).end();
  });

  function getImageSrc() {
    const width = activeImageData.width;
    const height = activeImageData.height;
    const channels = activeImageData.channels;

    const image = new Image(width, height, {
      colorModel:
        channels === 4
          ? ColorModel.RGB
          : channels === 3
          ? ColorModel.RGB
          : ColorModel.GREY,
      alpha: channels === 4 ? 1 : 0,
    });
    image.data.set(activeImageData.data);
    return image.toDataURL("image/png");
  }

  function showImage() {
    const src = getImageSrc();
    const width = activeImageData.width;
    const height = activeImageData.height;
    const name = activeImageData.name;
    const scaleMode = activeImageData.scaleMode;
    if (globalMainWindow) {
      try {
        globalMainWindow.webContents.send("image-data", {
          src,
          width,
          height,
          name,
          scaleMode,
        });
      } catch (error) {
        console.error("Could send image data over IPC", error);
      }
    }

    // send the info to the renderer process via IPC
    // It may be slow, but it is expected that IPC will not FAIL on large data
    // hopefull, requires testing
  }

  expressApp.post("/pixels/put", (req, res) => {
    if (typeof req.body !== "object" || req.body === null) {
      return res.status(400).send("Request body must be an object");
    }
    if (
      typeof req.body.offset !== "number" ||
      typeof req.body.bytesBase64 !== "string"
    ) {
      return res
        .status(400)
        .send(
          "Request body must contain 'offset' and 'bytesBase64' properties"
        );
    }
    const reqObject = req.body as {
      offset: number;
      bytesBase64: string;
    };
    const bytes = Buffer.from(reqObject.bytesBase64, "base64");
    const startIndex = reqObject.offset;
    activeImageData.data.set(new Uint8ClampedArray(bytes), startIndex);
    const endIndex = startIndex + bytes.length;
    if (endIndex > activeImageData.data.length) {
      return res
        .status(400)
        .send(
          "Attempted to write data out of bounds of array constructed from the width, height, and #channels information"
        );
    }
    res.status(204).end();
  });

  expressApp.get("/pixels/show", (req, res) => {
    showImage();
    res.status(204).end();
  });

  expressServer = expressApp.listen(0, () => {
    const port = (expressServer!.address() as { port: number }).port;
    console.log(`Server listening at http://localhost:${port}`);
    fs.writeFileSync(portFilePath, port.toString());
    globalReportInterval = setInterval(() => {
      if (globalMainWindow && reportPort) {
        try {
          globalMainWindow.webContents.send("express-port-found", port);
        } catch (e) {
          console.error("Error reporting port to renderer process:", e);
        }
      }
    }, 500);
  });
};

// Create the Electron window
const createWindow = (): void => {
  const { width, height } = screen.getPrimaryDisplay().workAreaSize;

  // Create the browser window.
  const mainWindow = new BrowserWindow({
    width,
    height,
    webPreferences: {
      nodeIntegration: true,
      contextIsolation: false,
      preload: MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY,
    },
  });

  globalMainWindow = mainWindow;

  reportPort = true;

  // and load the index.html of the app.
  mainWindow.loadURL(MAIN_WINDOW_WEBPACK_ENTRY);

  // Open the DevTools.
  // mainWindow.webContents.openDevTools();
};

// Wait for both the Express server and Electron to be ready
const initializeApp = async (): Promise<void> => {
  await createExpressServer();

  app.on("ready", createWindow);
};

// Initialize the application
initializeApp().catch((err) => console.error(err));

// Quit when all windows are closed, except on macOS. There, it's common
// for applications and their menu bar to stay active until the user quits
// explicitly with Cmd + Q.
app.on("window-all-closed", () => {
  if (process.platform !== "darwin") {
    app.quit();
  }
  reportPort = false;
});

app.on("activate", () => {
  // On OS X it's common to re-create a window in the app when the
  // dock icon is clicked and there are no other windows open.
  if (BrowserWindow.getAllWindows().length === 0) {
    createWindow();
  }
});

// Cleanup procedure before quitting the app
app.on("before-quit", () => {
  // Close the Express server
  if (expressServer) {
    expressServer.close(() => {
      console.log("Express server closed");
    });
  }
  if (globalReportInterval) {
    clearInterval(globalReportInterval);
  }
  if (fs.existsSync(portFilePath)) {
    fs.unlinkSync(portFilePath);
  }
});
