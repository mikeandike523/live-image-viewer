import { app, BrowserWindow, ipcMain, screen } from "electron";
import express, { Express } from "express";
import fs from "fs";
import path from "path";
import { Image } from "image-js";
import bodyParser from "body-parser";
import { channel } from "diagnostics_channel";

let callCwd = process.cwd();

if(process.env.CALL_DIR){
  callCwd = process.env.CALL_DIR
}

enum ColorModel {
  GREY = "GREY",
  RGB = "RGB",
  HSL = "HSL",
  HSV = "HSV",
  CMYK = "CMYK",
}

const portFilePath = path.join(callCwd, ".liv-port");

let globalMainWindow: BrowserWindow | null = null;
let globalReportInterval: NodeJS.Timeout | null = null;
let reportPort = false;

const scaleModes = ["fit-preserve-aspect", "unchanged"] as const;

type ScaleMode = (typeof scaleModes)[number];

// This allows TypeScript to pick up the magic constants that's auto-generated by Forge's Webpack
// plugin that tells the Electron app where to look for the Webpack-bundled app code (depending on
// whether you're running in development or production).
declare const MAIN_WINDOW_WEBPACK_ENTRY: string;
declare const MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY: string;

// Handle creating/removing shortcuts on Windows when installing/uninstalling.
if (require("electron-squirrel-startup")) {
  app.quit();
}

// Variable to hold the Express server reference
let expressServer: ReturnType<Express["listen"]> | null = null;

type ImageData = {
  name: string;
  width: number;
  height: number;
  channels: number;
  data: Uint8ClampedArray;
  scaleMode: ScaleMode;
};

const activeImageData: ImageData = {
  name: "",
  width: 0,
  height: 0,
  channels: 0,
  data: new Uint8ClampedArray(0).fill(0),
  scaleMode: "fit-preserve-aspect",
};

let hasRenderedImage = false;

function dataToRGBAData(
  data: Uint8ClampedArray,
  initChannels: number,
  defaultAlpha = 255
): Uint8ClampedArray {
  if (![1, 3, 4].includes(initChannels)) {
    throw new Error(
      `Invalid number of channels: ${initChannels}. Must be 1, 3, or 4.`
    );
  }
  const singleChannelLength = Math.floor(data.length / initChannels);
  const resultData = new Uint8ClampedArray(singleChannelLength * 4);
  const rData = new Uint8ClampedArray(singleChannelLength).fill(0);
  const gData = new Uint8ClampedArray(singleChannelLength).fill(0);
  const bData = new Uint8ClampedArray(singleChannelLength).fill(0);
  const aData = new Uint8ClampedArray(singleChannelLength).fill(defaultAlpha);
  if (initChannels == 3 || initChannels === 4) {
    for (let i = 0; i < singleChannelLength; i++) {
      const initR = data[i * initChannels];
      const initG = data[i * initChannels + 1];
      const initB = data[i * initChannels + 2];
      rData[i] = initR;
      gData[i] = initG;
      bData[i] = initB;
      if (initChannels === 4) {
        const initA = data[i * initChannels + 3];
        aData[i] = initA;
      }
    }
  }
  if (initChannels === 1) {
    rData.set(data);
    gData.set(data);
    bData.set(data);
  }

  for (let i = 0; i < singleChannelLength; i++) {
    resultData[i * 4] = rData[i];
    resultData[i * 4 + 1] = gData[i];
    resultData[i * 4 + 2] = bData[i];
    resultData[i * 4 + 3] = aData[i];
  }

  return resultData;
}

function getImageSrc() {
  const width = activeImageData.width;
  const height = activeImageData.height;
  const channels = activeImageData.channels;

  const image = new Image(width, height, {
    colorModel: ColorModel.RGB,
    alpha: 1,
  });

  console.log(image.data.length,dataToRGBAData(activeImageData.data, channels).length)

  image.data.set(dataToRGBAData(activeImageData.data, channels));
  return image.toDataURL("image/png");
}

function showImage() {
  const src = getImageSrc();
  const width = activeImageData.width;
  const height = activeImageData.height;
  const name = activeImageData.name;
  const scaleMode = activeImageData.scaleMode;

  if (globalMainWindow) {
    try {
      hasRenderedImage = true;

      globalMainWindow.webContents.send("image-data", {
        src,
        width,
        height,
        name,
        scaleMode,
      });
    } catch (error) {
      console.error("Could send image data over IPC", error);
    }
  }
}

// Create the Express server
const createExpressServer = async (): Promise<void> => {
  const expressApp = express();

  expressApp.use(bodyParser.json());

  // A route meant for clients to upload images as pixel data
  // It is called /pixels instead of /upload since it
  // is not uploading a file, just uploading pixel data
  // This is why a name is needed as it cannot be derived from
  // a file path
  expressApp.post("/pixels/begin", (req, res) => {
    hasRenderedImage = false;
    if (typeof req.body !== "object" || req.body === null) {
      return res.status(400).json({
        message: "Request body must be an object",
      });
    }
    if (
      typeof req.body.name !== "string" ||
      typeof req.body.width !== "number" ||
      typeof req.body.height !== "number" ||
      typeof req.body.channels !== "number" ||
      typeof req.body.scaleMode !== "string"
    ) {
      return res.status(400).json({
        message:
          "Request body must contain 'name', 'width', 'height', and 'channels' properties",
      });
    }
    if (!scaleModes.includes(req.body.scaleMode as ScaleMode)) {
      return res.status(400).json({
        message: `Invalid scale mode. Must be one of: ${scaleModes.join(", ")}`,
      });
    }
    const reqObject = req.body as {
      name: string;
      width: number;
      height: number;
      channels: number;
      scaleMode: ScaleMode;
    };
    console.log(reqObject.channels)
    const dataLength = reqObject.width * reqObject.height * reqObject.channels;
    activeImageData.name = reqObject.name;
    activeImageData.width = reqObject.width;
    activeImageData.height = reqObject.height;
    activeImageData.channels = reqObject.channels;
    activeImageData.data = new Uint8ClampedArray(dataLength).fill(0);
    activeImageData.scaleMode = reqObject.scaleMode;
    return res.status(204).end();
  });

  expressApp.post("/pixels/put", (req, res) => {
    if (typeof req.body !== "object" || req.body === null) {
      return res.status(400).send("Request body must be an object");
    }
    if (
      typeof req.body.offset !== "number" ||
      typeof req.body.bytesBase64 !== "string"
    ) {
      return res
        .status(400)
        .send(
          "Request body must contain 'offset' and 'bytesBase64' properties"
        );
    }
    const reqObject = req.body as {
      offset: number;
      bytesBase64: string;
    };
    const bytes = new Uint8ClampedArray(Buffer.from(reqObject.bytesBase64, "base64"));
    const startIndex = reqObject.offset;
    const endIndex = Math.min(activeImageData.data.length,startIndex + bytes.length);
    const numBytes = Math.min(bytes.length, endIndex - startIndex);
    const bytesSubset = bytes.slice(0, numBytes);
    console.log(bytes.length,startIndex,endIndex,numBytes,activeImageData.data.length, bytesSubset.length);
    activeImageData.data.set(bytesSubset, startIndex);
    res.status(204).end();
  });

  expressApp.get("/pixels/show", (req, res) => {
    showImage();
    res.status(204).end();
  });

  expressServer = expressApp.listen(0, () => {
    const port = (expressServer!.address() as { port: number }).port;
    console.info(`Server listening at http://localhost:${port}`);
    fs.writeFileSync(portFilePath, port.toString());
    globalReportInterval = setInterval(() => {
      if (globalMainWindow && reportPort) {
        try {
          globalMainWindow.webContents.send("express-port-found", port);
        } catch (e) {
          console.error("Error reporting port to renderer process:", e);
        }
      }
    }, 500);
  });
};

// Create the Electron window
const createWindow = (): void => {
  const { width, height } = screen.getPrimaryDisplay().workAreaSize;

  // Create the browser window.
  const mainWindow = new BrowserWindow({
    width,
    height,
    webPreferences: {
      nodeIntegration: true,
      contextIsolation: false,
      preload: MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY,
    },
  });

  globalMainWindow = mainWindow;

  reportPort = true;

  // and load the index.html of the app.
  mainWindow.loadURL(MAIN_WINDOW_WEBPACK_ENTRY);

  ipcMain.on("frontend-app-loaded", (event, hasLoaded) => {
    if (hasRenderedImage && hasLoaded) {
      showImage();
    }
  });
};

// Wait for both the Express server and Electron to be ready
const initializeApp = async (): Promise<void> => {
  await createExpressServer();

  app.on("ready", createWindow);
};

// Initialize the application
initializeApp().catch((err) => console.error(err));

// Quit when all windows are closed, except on macOS. There, it's common
// for applications and their menu bar to stay active until the user quits
// explicitly with Cmd + Q.
app.on("window-all-closed", () => {
  if (process.platform !== "darwin") {
    app.quit();
  }
  reportPort = false;
});

app.on("activate", () => {
  // On OS X it's common to re-create a window in the app when the
  // dock icon is clicked and there are no other windows open.
  if (BrowserWindow.getAllWindows().length === 0) {
    createWindow();
  }
});

// Cleanup procedure before quitting the app
app.on("before-quit", () => {
  // Close the Express server
  if (expressServer) {
    expressServer.close(() => {
      console.info("Express server closed");
    });
  }
  if (globalReportInterval) {
    clearInterval(globalReportInterval);
  }
  if (fs.existsSync(portFilePath)) {
    fs.unlinkSync(portFilePath);
  }
});
